
library ChangeLog requires Utils, ArgsUtils, Constants {

    type IntFn extends function(integer);
    type StringFn extends function(string);

    public struct ChangeLog {

        static TableArray changes;
        static Table      versions;
        static integer    numVersions;

        private integer   major;
        private integer   minor;
        private integer   rev;
        private integer   length;
        private string    version;

        static method create(integer major, integer minor, integer rev) -> thistype {
            thistype this = thistype.allocate();

            this.major   = major;
            this.minor   = minor;
            this.rev     = rev;
            this.length  = 0;
            this.version = I2S(major) + "." + I2S(minor) + A2S(rev);

            thistype.numVersions += 1;
            thistype.versions.integer_s[version] = this;
            
            return this;
        }

        method toString() -> string {
            return "v" + version;
        }

        method operator to_s() -> string {
            return toString();
        }

        method push(string change) {
            changes[this].string[length] = change;
            length += 1;
        }

        method add(string change) {
            push(change);
        }

        method each(player p, StringFn f) {
            integer i = 0;
            for (0 <= i < length) {
                f.evaluate(changes[this].string[i]);
            }
        }

        method operator<(thistype t) -> boolean {
            if (major < t.major)
                return true;
            if (major > t.major)
                return false;
            if (minor < t.minor)
                return true;
            if (minor > t.minor)
                return false;
            return rev < t.rev;
        }

        method toFormattedString() -> string {
            integer i = 0;
            string  s = "";
            s += GENERAL_COLOR + "Change Log for|r " + GOLD_COLOR + toString() + "|r|n";
            for ( 0 <= i < length ) {
                s += HIGHLIGHT_COLOR + changes[this].string[i] + "|r|n";
            }
            return s + "|n";
        }

        method displayForPlayer(player p) {
            integer i = 0;
            DisplayTimedTextToPlayer( p, 0, 0, 30, GENERAL_COLOR + "Change Log for " + GOLD_COLOR + toString() );
            for (0 <= i < length) {
                DisplayTimedTextToPlayer( p, 0, 0, 30, HIGHLIGHT_COLOR + changes[this].string[i] );
            }
        }

        static method foreach(IntFn fn) {
            integer i = 0;
            for ( 0 <= i <= thistype.numVersions )
                fn.evaluate(thistype(i));
        }

        static method operator newest () -> thistype {
            integer i;
            integer n = thistype(1);

            for ( 2 <= i <= numVersions ) {
                if ( thistype(i) > thistype(n) ) {
                    n = thistype(i);
                }
            }

            return n;
        }

        static method getVersion(string whichVersion) -> thistype {
            return thistype( thistype.versions.integer_s[whichVersion] );
        }

        static method onInit() {
            changes     = TableArray[0x2000];
            versions    = Table.create();
            numVersions = 0;
        }

        method inspect() {
            debug {
                integer i;
                BJDebugMsg( "Inspecting ChangeLog " + I2S(this) );
                BJDebugMsg( "major=" + I2S(major) );
                BJDebugMsg( "minor=" + I2S(minor) );
                BJDebugMsg( "rev=" + I2S(rev) );
                BJDebugMsg( "version=" + version ) ;
                for ( 0 <= i < length ) {
                    BJDebugMsg( "changes[this][" + I2S(i) + "]=" + changes[this].string[i] );
                }
            }
        }

        static method inspectAll() {  
            debug {
                BJDebugMsg( "Inspecting ChangeLogs" );
                BJDebugMsg( "numVersions=" + I2S(numVersions) );
                BJDebugMsg( "newest=" + I2S(newest) );
                thistype.foreach( function(ChangeLog i){
                    i.inspect();
                });
            }
        }
    }

    function CreateChangeLogQuest() {
        integer i = 0;
        string  s = SPECIAL_COLOR + "Change Logs|r|n|n";

        for ( 0 < i <= ChangeLog.numVersions ) {
            s += ChangeLog(i).toFormattedString();
        }

        CreateQuestBJ( 
            bj_QUESTTYPE_REQ_DISCOVERED,
            SPECIAL_COLOR + "Change Logs|r|n|n",
            s,
            "ReplaceableTextures\\CommandButtons\\BTNBerserkForTrolls.blp"
        );
    }

    function DisplayNotice() {
        ReleaseTimer( GetExpiredTimer() );
        DisplayTextToPlayer( GetLocalPlayer(), 0, 0, ChangeLogNoticeString );
    }

    function onInit() {
		TimerStart( NewTimer(), 120, false, function DisplayNotice );


        ChatCommands.registerArgFunc( null, "changelog", function(ArgsList a) {
            if ( a[0] == "" )
                ChangeLog.newest.displayForPlayer( a.triggerPlayer );
            else
                ChangeLog.getVersion( a[0] ).displayForPlayer( a.triggerPlayer );
        });

        TimerStart( NewTimer(), 0., false, function() {
            ReleaseTimer( GetExpiredTimer() );
            CreateChangeLogQuest();
        });
    }
}